////////////////////////////////////////////////////////////////////////////////////////////
// Copyright Â© 2020 xx network SEZC                                                       //
//                                                                                        //
// Use of this source code is governed by a license that can be found in the LICENSE file //
////////////////////////////////////////////////////////////////////////////////////////////

package wallet

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"strings"

	"github.com/tyler-smith/go-bip39"
	"github.com/xx-labs/sleeve/hasher"
	"github.com/xx-labs/sleeve/wots"
)

const EntropySize = 32
const MnemonicWords = 24

///////////////////////////////////////////////////////////////////////
// SLEEVE WALLET
/*
	Sleeve is a novel way of embedding a quantum secure key in the
	generation of curve based, non quantum secure keys
	Find out more about Sleeve at: xx.network/sleeve

	A complete diagram of the Sleeve wallet generation can be found
	in the docs folder. This implementation of Sleeve uses a WOTS+
	key as the underlying quantum secure key, and the diagram for
	the generation of this key can also be found in the docs folder.

	Essentially, the input for wallet generation is random entropy,
	which is encoded into a mnemonic phrase using BIP39. Then a BIP44
	custom path of m/44'/1955'/0'/0'/0' is used in a BIP32 derivation
	to generate a 256 bit child private key and 256 bit chain code.

	The private key and chain code are used, respectively, as the
	secret and public seeds in WOTS+ generation. After the WOTS+ key
	is generated, we save the quantum secure public key (PK).
	This public key will be used as the Wallet address when full
	quantum secure capabilities are implemented in the future.

	The private key is also used to derive a "sleeve secret key".
	This secret key allows the WOTS+ public key to be safely shared
	at anytime, without compromising the non quantum secure keys
	generated by Sleeve. This secret key will be used in the future
	to redeem non quantum secure wallets into the WOTS+ quantum
	secure wallet.

	The sleeve output is generated using SHA3_256 to hash the
	sleeve private key and WOTS+ public key together. The resulting
	hash value is then encoded using BIP39, providing the output
	mnemonic, which can be used to generate non quantum secure keys
	on any blockchain platform.
*/
type Sleeve struct {
	// Sleeve mnemonic: used to recover a Sleeve wallet
	// User must store this safely for future use
	mnemonic  string
	// Output mnemonic: used to generate/recover any non quantum secure wallets
	// User must store this safely, but in case of loss, it can be
	// regenerated from the Sleeve mnemonic
	output    string
}

// Generation spec for a Sleeve wallet
// Account and WOTS+ params can be specified
type GenSpec struct {
	account uint32
	params  wots.ParamsEncoding
}

func DefaultGenSpec() GenSpec {
	return GenSpec{
		account: 0,
		params:  wots.DefaultParams,
	}
}

func NewGenSpec(account uint32, params wots.ParamsEncoding) GenSpec {
	return GenSpec{
		account: account,
		params:  params,
	}
}

func (g GenSpec) PathFromSpec() (Path, error) {
	return NewPath(g.account, uint32(g.params), 0)
}

///////////////////////////////////////////////////////////////////////
// CONSTRUCTORS

// Create a sleeve reading entropy from the provided CSPRNG, with the supplied passphrase
// and using the given generation spec
func NewSleeve(csprng io.Reader, passphrase string, spec GenSpec) (*Sleeve, error) {
	// 1. Read EntropySize bytes of entropy from csprng
	ent := make([]byte, EntropySize)
	if n, err := csprng.Read(ent); n != EntropySize || err != nil {
		return nil, errors.New("couldn't read enough bytes of entropy from provided reader")
	}

	// 2. Get sleeve from entropy
	return NewSleeveFromEntropy(ent, passphrase, spec)
}

// Create a sleeve with provided entropy, passphrase and using the given generation spec
// Entropy must have 32 bytes
func NewSleeveFromEntropy(ent []byte, passphrase string, spec GenSpec) (*Sleeve, error) {
	// 1. Generate BIP39 mnemonic from entropy
	// (fails if entropy is not 16, 20, 24, 28 or 32 bytes)
	mnem, err := bip39.NewMnemonic(ent)
	if err != nil {
		return nil, err
	}

	// 2. Validate entropy has Sleeve required size of EntropySize
	if len(ent) != EntropySize {
		return nil, errors.New("provided entropy is of incorrect size")
	}

	// 3. Get Sleeve from mnemonic
	return NewSleeveFromMnemonic(mnem, passphrase, spec)
}

// Create a sleeve with provided mneomonic and passphrase
// Mnemonic must be valid under BIP39 and have 24 words
func NewSleeveFromMnemonic(mnemonic, passphrase string, spec GenSpec) (*Sleeve, error) {
	// 1. Validate mnemonic has MnemonicWords words
	words := strings.Fields(mnemonic)

	if len(words) != MnemonicWords {
		return nil, errors.New("mnemonic has invalid number of words")
	}

	// 2. Generate sleeve (internally validates mnemonic)
	sl, err := generateSleeveFromMnemonic(mnemonic, passphrase, spec)
	if err != nil {
		return nil, err
	}

	return sl, nil
}

///////////////////////////////////////////////////////////////////////
// GETTERS

// Get the Sleeve's quantum secure mnemonic
func (s *Sleeve) GetMnemonic() string {
	return s.mnemonic
}

// Get the Sleeve's standard mnemonic (output)
func (s *Sleeve) GetOutputMnemonic() string {
	return s.output
}

///////////////////////////////////////////////////////////////////////
// PRIVATE

// Generate the sleeve according to the generation spec
// (diagram found in the docs folder)
func generateSleeveFromMnemonic(mnemonic, passphrase string, spec GenSpec) (*Sleeve, error) {
	// 1. Generate seed from mnemonic (validates the mnemonic)
	seed, err := bip39.NewSeedWithErrorChecking(mnemonic, passphrase)
	if err != nil {
		return nil, err
	}

	// 2. Get path and wots params from GenSpec
	path, err := spec.PathFromSpec()
	if err != nil {
		return nil, err
	}
	params := wots.DecodeParams(spec.params)
	if params == nil {
		return nil, errors.New("unknown WOTS+ params encoding")
	}

	// 3. Derive seeds using BIP32 and path
	node, err := ComputeNode(seed, path)
	if err != nil {
		return nil, err
	}

	// 4. Generate sleeve
	out := generateSleeve(node.Key, node.Code, params)

	// 5. Encode output into BIP39 mnemonic
	outMnem, _ := bip39.NewMnemonic(out)

	// 6. Create sleeve
	s := &Sleeve{
		mnemonic:  mnemonic,
		output:    outMnem,
	}
	return s, nil
}

// Generate a Sleeve
// Takes secret seed and public seed as input
// Generates WOTS+ key from the seeds and also a sleeve secret key
// Returns the sleeve output entropy
func generateSleeve(secretSeed, publicSeed []byte, params *wots.Params) []byte {
	// 1. Generate WOTS+ key from seed and public seed
	wotsKey := wots.NewKeyFromSeed(params, secretSeed, publicSeed)

	// 2. Get WOTS+ Pubic Key
	pk := wotsKey.ComputePK()

	// 3. Derive Sleeve secret key and return output
	secretKey := hasher.SHA3_256.Hash(append([]byte("xx network sleeve"), secretSeed...))
	return hasher.SHA3_256.Hash(append(secretKey, pk...))
}

///////////////////////////////////////////////////////////////////////
// SINGLE-SEED SLEEVE WALLET
/*
	SingleSeedSleeve provides an alternative generation method that uses
	only a single mnemonic phrase instead of generating a second output
	mnemonic. This improves user experience while maintaining quantum
	security.

	The WOTS+ public key is used to derive an index value that extends
	the BIP32 derivation path for each network. This maintains the
	cryptographic binding between quantum-secure WOTS+ keys and classical
	ECDSA keys.

	Path structure:
	- Quantum path: m/44'/1955'/0'/0'/0' (unchanged)
	- Network paths: m/44'/{coin}'/0'/0/{wots_index}
	  where {wots_index} = first_4_bytes(SHA3_256(WOTS_PK))

	This approach supports any BIP44-compliant network automatically.
*/

// Network coin type constants for BIP44 derivation
const (
	CoinTypeBitcoin  uint32 = 0
	CoinTypeEthereum uint32 = 60
	CoinTypePolkadot uint32 = 354
	CoinTypeLitecoin uint32 = 2
	CoinTypeCardano  uint32 = 1815
)

// NetworkKey represents a derived key for a specific network
type NetworkKey struct {
	Network  string // Network name (e.g., "Bitcoin", "Ethereum")
	CoinType uint32 // BIP44 coin type
	Path     string // Full derivation path
	Key      []byte // Derived private key
}

// SingleSeedSleeve represents a Sleeve wallet using single seed generation
type SingleSeedSleeve struct {
	// Input mnemonic: the single phrase users need to backup
	mnemonic string
	// WOTS+ keypair for quantum security
	wotsKey *wots.Key
	// WOTS+ public key (cached)
	wotsPK []byte
	// Derivation index calculated from WOTS public key
	derivationIndex uint32
	// Derived network keys
	networkKeys map[string]*NetworkKey
}

///////////////////////////////////////////////////////////////////////
// SINGLE-SEED CONSTRUCTORS

// Create a single-seed sleeve reading entropy from the provided CSPRNG
func NewSingleSeedSleeve(csprng io.Reader, passphrase string, spec GenSpec) (*SingleSeedSleeve, error) {
	// 1. Read EntropySize bytes of entropy from csprng
	ent := make([]byte, EntropySize)
	if n, err := csprng.Read(ent); n != EntropySize || err != nil {
		return nil, errors.New("couldn't read enough bytes of entropy from provided reader")
	}

	// 2. Get sleeve from entropy
	return NewSingleSeedSleeveFromEntropy(ent, passphrase, spec)
}

// Create a single-seed sleeve with provided entropy
func NewSingleSeedSleeveFromEntropy(ent []byte, passphrase string, spec GenSpec) (*SingleSeedSleeve, error) {
	// 1. Generate BIP39 mnemonic from entropy
	mnem, err := bip39.NewMnemonic(ent)
	if err != nil {
		return nil, err
	}

	// 2. Validate entropy has required size
	if len(ent) != EntropySize {
		return nil, errors.New("provided entropy is of incorrect size")
	}

	// 3. Get Sleeve from mnemonic
	return NewSingleSeedSleeveFromMnemonic(mnem, passphrase, spec)
}

// Create a single-seed sleeve with provided mnemonic and passphrase
func NewSingleSeedSleeveFromMnemonic(mnemonic, passphrase string, spec GenSpec) (*SingleSeedSleeve, error) {
	// 1. Validate mnemonic has MnemonicWords words
	words := strings.Fields(mnemonic)
	if len(words) != MnemonicWords {
		return nil, errors.New("mnemonic has invalid number of words")
	}

	// 2. Generate single-seed sleeve
	return generateSingleSeedSleeveFromMnemonic(mnemonic, passphrase, spec)
}

///////////////////////////////////////////////////////////////////////
// SINGLE-SEED GETTERS

// Get the single mnemonic phrase (only one needed for recovery)
func (s *SingleSeedSleeve) GetMnemonic() string {
	return s.mnemonic
}

// Get the WOTS+ public key (quantum-secure address)
func (s *SingleSeedSleeve) GetWOTSPublicKey() []byte {
	return s.wotsPK
}

// Get the derivation index calculated from WOTS public key
func (s *SingleSeedSleeve) GetDerivationIndex() uint32 {
	return s.derivationIndex
}

// Get a private key for a specific network by name
func (s *SingleSeedSleeve) GetPrivateKey(network string) ([]byte, error) {
	key, exists := s.networkKeys[network]
	if !exists {
		return nil, fmt.Errorf("network %s not found - call DeriveNetworkKey first", network)
	}
	return key.Key, nil
}

// Get all derived network keys
func (s *SingleSeedSleeve) GetAllNetworkKeys() map[string]*NetworkKey {
	return s.networkKeys
}

// Get the WOTS+ key for signing (if needed in future)
func (s *SingleSeedSleeve) GetWOTSKey() *wots.Key {
	return s.wotsKey
}

///////////////////////////////////////////////////////////////////////
// NETWORK KEY DERIVATION

// Derive a key for a specific network using its coin type
func (s *SingleSeedSleeve) DeriveNetworkKey(network string, coinType uint32, seed []byte) error {
	// Derive to m/44'/{coinType}'/0'/0 using manual BIP32 derivation
	// ComputeNode is designed for the quantum path (5 hardened elements)
	// Network paths require 4 hardened + 1 non-hardened element

	// 1. Create master node
	node, err := NewMasterNode(seed)
	if err != nil {
		return fmt.Errorf("failed to create master node: %v", err)
	}

	// 2. Derive m/44'
	err = node.ComputeHardenedChild(0x8000002C)
	if err != nil {
		return fmt.Errorf("failed to derive purpose: %v", err)
	}

	// 3. Derive m/44'/{coinType}'
	err = node.ComputeHardenedChild(coinType | firstHardened)
	if err != nil {
		return fmt.Errorf("failed to derive coin type: %v", err)
	}

	// 4. Derive m/44'/{coinType}'/0'
	err = node.ComputeHardenedChild(0x80000000)
	if err != nil {
		return fmt.Errorf("failed to derive account: %v", err)
	}

	// 5. Derive m/44'/{coinType}'/0'/0'
	err = node.ComputeHardenedChild(0x80000000)
	if err != nil {
		return fmt.Errorf("failed to derive change: %v", err)
	}

	// 6. Extend with WOTS-derived index (non-hardened)
	finalNode, err := node.Child(s.derivationIndex)
	if err != nil {
		return fmt.Errorf("failed to derive final key with WOTS index: %v", err)
	}

	// Store the network key
	fullPath := fmt.Sprintf("m/44'/%d'/0'/0/%d", coinType, s.derivationIndex)
	s.networkKeys[network] = &NetworkKey{
		Network:  network,
		CoinType: coinType,
		Path:     fullPath,
		Key:      finalNode.Key,
	}

	return nil
}

// Derive keys for common networks (Bitcoin, Ethereum, Polkadot)
func (s *SingleSeedSleeve) DeriveStandardNetworks(seed []byte) error {
	networks := []struct {
		name     string
		coinType uint32
	}{
		{"Bitcoin", CoinTypeBitcoin},
		{"Ethereum", CoinTypeEthereum},
		{"Polkadot", CoinTypePolkadot},
	}

	for _, net := range networks {
		if err := s.DeriveNetworkKey(net.name, net.coinType, seed); err != nil {
			return fmt.Errorf("failed to derive %s key: %v", net.name, err)
		}
	}

	return nil
}

///////////////////////////////////////////////////////////////////////
// PRIVATE - SINGLE SEED GENERATION

// Generate the single-seed sleeve according to the generation spec
func generateSingleSeedSleeveFromMnemonic(mnemonic, passphrase string, spec GenSpec) (*SingleSeedSleeve, error) {
	// 1. Generate seed from mnemonic (validates the mnemonic)
	seed, err := bip39.NewSeedWithErrorChecking(mnemonic, passphrase)
	if err != nil {
		return nil, err
	}

	// 2. Get path and wots params from GenSpec
	path, err := spec.PathFromSpec()
	if err != nil {
		return nil, err
	}
	params := wots.DecodeParams(spec.params)
	if params == nil {
		return nil, errors.New("unknown WOTS+ params encoding")
	}

	// 3. Derive quantum path using BIP32: m/44'/1955'/0'/0'/0'
	quantumNode, err := ComputeNode(seed, path)
	if err != nil {
		return nil, err
	}

	// 4. Generate WOTS+ keypair (unchanged from original Sleeve)
	wotsKey := wots.NewKeyFromSeed(params, quantumNode.Key, quantumNode.Code)
	wotsPK := wotsKey.ComputePK()

	// 5. Calculate derivation index from WOTS public key
	// Hash the WOTS PK and extract 31 bits to create a deterministic index
	// that binds the network keys to the quantum-secure WOTS keypair
	pkHash := hasher.SHA3_256.Hash(wotsPK)
	// Mask to 31 bits to ensure index < 2^31 (BIP32 non-hardened requirement)
	derivationIndex := binary.BigEndian.Uint32(pkHash[:4]) & 0x7FFFFFFF

	// 6. Create single-seed sleeve structure
	sleeve := &SingleSeedSleeve{
		mnemonic:        mnemonic,
		wotsKey:         wotsKey,
		wotsPK:          wotsPK,
		derivationIndex: derivationIndex,
		networkKeys:     make(map[string]*NetworkKey),
	}

	// 7. Automatically derive keys for standard networks
	err = sleeve.DeriveStandardNetworks(seed)
	if err != nil {
		return nil, err
	}

	return sleeve, nil
}
